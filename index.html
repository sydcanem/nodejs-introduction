<!doctype html>
<html lang="en">

	<head>
		<meta charset="utf-8">

		<title>Nodejs Introduction</title>

		<meta name="description" content="Introduction to Nodejs I/O Platform">
		<meta name="apple-mobile-web-app-capable" content="yes" />
		<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />

		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

		<link rel="stylesheet" href="css/reveal.min.css">
		<link rel="stylesheet" href="css/theme/default.css" id="theme">

		<!-- For syntax highlighting -->
		<link rel="stylesheet" href="lib/css/zenburn.css">

		<!-- If the query includes 'print-pdf', use the PDF print sheet -->
		<script>
			document.write( '<link rel="stylesheet" href="css/print/' + ( window.location.search.match( /print-pdf/gi ) ? 'pdf' : 'paper' ) + '.css" type="text/css" media="print">' );

		</script>

		<style type="text/css">
			.ceil .present {
				text-align: left;
			}
		</style>

		<!--[if lt IE 9]>
		<script src="lib/js/html5shiv.js"></script>
		<![endif]-->
	</head>

	<body>

		<div class="reveal">

			<!-- Any section element inside of this container is displayed as a slide -->
			<div class="slides">
				<!-- Main slide -->
				<section>
					<h1>Introduction to Node.js</h1>
				</section>

				<!-- Brief history -->
				<section>
					<h3>A Very Brief History</h3>
					<ul>
						<li>
							created by Ryan Dahl
						</li>
						<li>
							v0.0.1 released in May 2009 (current stable v0.10.13)
						</li>
						<li>
							smash hit at JSConf 2009
						</li>
						<li>
							technology of the year 2012
						</li>
					</ul>
				</section>

				<!-- Description  -->
				<section data-state="ceil">
					<section>		
						<h2>What is Node.js?</h2>
						<p>
							Node.js is an event-driven I/O framework.
						</p>

						<aside class="notes">
							That's it! It's a simple and stable I/O platform built on top of Google's V8 javascript engine.

							V8 is a very complex virtual machine written by google. V8 is a javascript engine inside chrome.

							It's an open source project developed by Ryan Dahl and is designed to help us write Javascipt programs that talk to networks, file systems or other I/O sources.
						</aside>
					</section>
					<section>
						<h3>Node is not</h3>
						<ul>
							<li>A web framework</li>
							<li>A programming language</li>
						</ul>
						<br />
						<br />
						<h3>Node is</h3>
						<ul>
							<li>A tool for creating I/O based programs that need to be fast and/or handle lots of connections</li>
						</ul>
					</section>
					<section>
						<h3>Examples of I/O based programs:</h3>
						<ul>
							<li>Databases (e.g. MySQL, PostgreSQL, MongoDB, Redis, CouchDB)</li>
							<li>APIs (e.g. Twitter, Facebook)</li>
							<li>HTTP/WebSocket connections (from users of a web app)</li>
							<li>Files (image resizer, video editor, internet radio)</li>
						</ul>

						<aside class="notes">
							Node does I/O in a different way. [Next] It's asynchronous in nature. 
						</aside>
					</section>
				</section>

				<section>
					<section>
						<h3>Node is asynchronous</h3>
						<p>... which lets it handle lots of different things simultaneously.</p>
					</section>
					<section>
						<h3>Asynchronous?</h3>
					</section>
					<section>
						<h3>consider this analogy...</h3>
						<p>You go down to a fast food joint and order a cheeseburger, they will immediately take your order and then make you wait around until the cheeseburger is ready. In the meantime they can take other orders and start cooking cheeseburgers for other people. Imagine if you had to wait at the register for your cheeseburger, blocking all other people in line from ordering while they cooked your burger! This is called blocking I/O because all I/O (cooking cheeseburgers) happens one at a time. Node, on the other hand, is non-blocking, which means it can cook many cheeseburgers at once.
						</p>
					</section>
				</section>

				<section>
					<section>
						<h3>Node uses an event-loop to perform non-blocking and asynchronous I/O</h3>
						<p>an event-loop is a mechanism which allows you to specify what happens when a particular event occurs. You can think of it as a simple list of tasks bound to be executed when a certain event occurs.</p>
					</section>
					<section>
						<p>consider this jQuery code...</p>
						<pre><code data-trim contenteditable>
$.post('/resource.json',			// I/O does not block execution
	function (data) {
		console.log(data)
});						
						</code></pre>
						<aside class="notes">
							This jQuery program performs an HTTP request resource.json. When the response comes back, an anonymous function is called (the "callback") containing the argument data.

							If this code is blocking execution, since browsers are single threaded, if this requests took 400ms to return, any other events happening on that timeframe would wait until data comes back. Imagine the poor user experience.
						</aside>
						<img src="images/browser_event_loop.png">
					</section>
					<section>
						<p>Node.js simply extends this idea to I/O operations: when you start an operation like reading a file, you can pass control to back to Node and have your code run when the data has been read. For example:</p>
						<pre><code data-trim contenteditable>
// read the file /etc/passwd, and call console.log on the returned data
fs.readFile('/etc/passwd', function(err, data){
  console.log(data);
});						
						</code></pre>
					</section>
					<section>
						<img src="images/node_event_loop.png">
					</section>
				</section>

				<section data-state="ceil">
					<section>
						<h3>Core modules</h3>
						<p>Node has small group of modules (referred to as 'node core') presented to the public as API that you are intended to write programs with.</p>
						<ul>
							<li><code>fs</code> - file system handling</li>
							<li><code>http, net, dgram</code> - for working with network systems</li>
							<li><code>os</code> - module for getting os information</li>
							<li><code>url, querystring, path</code> - for parsing urls and paths</li>
							<li><code>dns</code> - module for asynchronously resolving DNS queries</li>
						</ul>
						<p>and a lot more...</p>
						<br />
						<br />
						<a href="http://nodejs.org/api/" target="_blank"><small>http://nodejs.org/api/</small></a>
					</section>
				</section>

				<section>
					<section>
						<h3>Installation</h3>
					</section>
					<section>
						<h3>Windows</h3>
						<p>Download pre-compiled binaries from <a href="http://nodejs.org/download">http://nodejs.org/download</a></p>
						<br />
						<br />
						<h3>Linux / Unix</h3>
						<pre><code data-trim contenteditable>
$ git clone https://github.com/joyent/node
$ cd node
$ configure 
$ make && make install
						</code></pre>
					</section>
				</section>

				<section>
					<section>
						<h3>Ready for actual coding</h3>
					</section>
				</section>

			</div>

		</div>

		<script src="lib/js/head.min.js"></script>
		<script src="js/reveal.min.js"></script>

		<script>

			// Full list of configuration options available here:
			// https://github.com/hakimel/reveal.js#configuration
			Reveal.initialize({
				controls: true,
				progress: true,
				history: true,
				center: true,

				theme: 'night', // Reveal.getQueryHash().theme, // available themes are in /css/theme
				transition: 'linear', //Reveal.getQueryHash().transition || 'default', // default/cube/page/concave/zoom/linear/fade/none

				// Optional libraries used to extend on reveal.js
				dependencies: [
					{ src: 'lib/js/classList.js', condition: function() { return !document.body.classList; } },
					{ src: 'plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ src: 'plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ src: 'plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } },
					{ src: 'plugin/zoom-js/zoom.js', async: true, condition: function() { return !!document.body.classList; } },
					{ src: 'plugin/notes/notes.js', async: true, condition: function() { return !!document.body.classList; } }
					// { src: 'plugin/search/search.js', async: true, condition: function() { return !!document.body.classList; } }
					// { src: 'plugin/remotes/remotes.js', async: true, condition: function() { return !!document.body.classList; } }
				]
			});

			// Listeners
		</script>

	</body>
</html>
